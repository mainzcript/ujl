import type { UJLAbstractNode, UJLCModuleObject } from "@ujl-framework/types";
import type { Composer } from "../composer.js";
import { Field } from "../fields/index.js";
import { generateUid } from "../utils.js";
import { Slot } from "./slot.js";
import type { ComponentCategory } from "./types.js";

/**
 * Represents a single field definition within a module
 *
 * Contains the field key and the actual field instance.
 * Fields are naturally ordered by their position in the array.
 */
export type FieldEntry = {
	/** Unique identifier for this field within the module */
	key: string;
	/** The field instance that handles parsing, validation, and serialization */
	field: Field;
};

/**
 * Collection of field definitions for a module
 *
 * Array-based structure provides natural ordering without requiring explicit indices.
 * Fields are processed in the order they appear in the array.
 */
type FieldSet = ReadonlyArray<FieldEntry>;

/**
 * Represents a single slot definition within a module
 *
 * Contains the slot key and the actual slot instance.
 * Slots are naturally ordered by their position in the array.
 */
export type SlotEntry = {
	/** Unique identifier for this slot within the module */
	key: string;
	/** The slot instance that handles parsing, validation, and serialization */
	slot: Slot;
};

/**
 * Collection of slot definitions for a module
 *
 * Array-based structure provides natural ordering without requiring explicit indices.
 * Slots are processed in the order they appear in the array.
 */
type SlotSet = ReadonlyArray<SlotEntry>;

/**
 * Abstract base class for all UJL module types
 *
 * Defines the common interface that all modules must implement,
 * including their name, field definitions, slot configurations, and rendering.
 *
 * All UI metadata is required to ensure consistent component library behavior
 * and eliminate the need for fallback logic in UI components.
 */
export abstract class ModuleBase {
	/** Unique identifier for this module type */
	public abstract readonly name: string;

	/** Field definitions available in this module */
	public abstract readonly fields: FieldSet;

	/** Slot definitions for child modules */
	public abstract readonly slots: SlotSet;

	/**
	 * Compose a module instance into an abstract syntax tree node
	 * @param moduleData - The module data from UJL document
	 * @param composer - Composer instance for composing child modules
	 * @returns Composed abstract syntax tree node (can be async for image resolution)
	 */
	public abstract compose(
		moduleData: UJLCModuleObject,
		composer: Composer,
	): UJLAbstractNode | Promise<UJLAbstractNode>;

	/** Human-readable display name */
	public abstract readonly label: string;

	/** Description for component picker */
	public abstract readonly description: string;

	/** Category for grouping modules */
	public abstract readonly category: ComponentCategory;

	/** Searchable tags for filtering */
	public abstract readonly tags: readonly string[];

	/**
	 * SVG icon content (inner content of the SVG tag, without the svg wrapper)
	 * The full SVG will be generated by getSvgIcon() with consistent attributes
	 * Example: '<rect width="18" height="18" x="3" y="3" rx="2"/>'
	 */
	public abstract readonly icon: string;

	/**
	 * Get the complete SVG icon string with standardized attributes
	 * @returns Complete SVG string ready for rendering
	 */
	public getSvgIcon(): string {
		return `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${this.icon}</svg>`;
	}

	/**
	 * Helper method to parse a field value from module data
	 * @param moduleData - The module data from UJL document
	 * @param key - The field key to parse
	 * @param fallback - Fallback value if field is not found or parsing fails
	 * @returns Parsed field value or fallback
	 */
	protected parseField<T>(moduleData: UJLCModuleObject, key: string, fallback: T): T {
		const entry = this.fields.find((f) => f.key === key);
		if (!entry) return fallback;
		const parsed = entry.field.parse(moduleData.fields[key]);
		return (parsed ?? fallback) as T;
	}

	/**
	 * Helper to create an AST node with the required id and meta fields.
	 * @param type - Node type string matched by the adapter
	 * @param props - Type-specific props for the adapter
	 * @param moduleData - The module data from the UJL document (provides moduleId)
	 * @param isModuleRoot - true for the root node of a module, false for internal child nodes
	 */
	protected createNode(
		type: UJLAbstractNode["type"],
		props: Record<string, unknown>,
		moduleData: UJLCModuleObject,
		isModuleRoot = true,
	): UJLAbstractNode {
		return {
			type,
			props,
			id: generateUid(),
			meta: {
				moduleId: moduleData.meta.id,
				isModuleRoot,
			},
		} as UJLAbstractNode;
	}
}
