import type { UJLAbstractNode, UJLCModuleObject } from "@ujl-framework/types";
import type { Composer } from "../composer.js";
import { Field } from "../fields/index.js";
import { generateUid } from "../utils.js";
import { Slot } from "./slot.js";
import type { ComponentCategory } from "./types.js";

/**
 * Represents a single field definition within a module
 *
 * Contains the field key and the actual field instance.
 * Fields are naturally ordered by their position in the array.
 */
export type FieldEntry = {
	/** Unique identifier for this field within the module */
	key: string;
	/** The field instance that handles parsing, validation, and serialization */
	field: Field;
};

/**
 * Collection of field definitions for a module
 *
 * Array-based structure provides natural ordering without requiring explicit indices.
 * Fields are processed in the order they appear in the array.
 */
type FieldSet = ReadonlyArray<FieldEntry>;

/**
 * Represents a single slot definition within a module
 *
 * Contains the slot key and the actual slot instance.
 * Slots are naturally ordered by their position in the array.
 */
export type SlotEntry = {
	/** Unique identifier for this slot within the module */
	key: string;
	/** The slot instance that handles parsing, validation, and serialization */
	slot: Slot;
};

/**
 * Collection of slot definitions for a module
 *
 * Array-based structure provides natural ordering without requiring explicit indices.
 * Slots are processed in the order they appear in the array.
 */
type SlotSet = ReadonlyArray<SlotEntry>;

/**
 * Abstract base class for all UJL module types
 *
 * Defines the common interface that all modules must implement,
 * including their name, field definitions, slot configurations, and rendering.
 *
 * All UI metadata is required to ensure consistent component library behavior
 * and eliminate the need for fallback logic in UI components.
 */
export abstract class ModuleBase {
	/** Unique identifier for this module type */
	public abstract readonly name: string;

	/** Field definitions available in this module */
	public abstract readonly fields: FieldSet;

	/** Slot definitions for child modules */
	public abstract readonly slots: SlotSet;

	/**
	 * Compose a module instance into an abstract syntax tree node
	 * @param moduleData - The module data from UJL document
	 * @param composer - Composer instance for composing child modules
	 * @returns Composed abstract syntax tree node (can be async for image resolution)
	 */
	public abstract compose(
		moduleData: UJLCModuleObject,
		composer: Composer,
	): UJLAbstractNode | Promise<UJLAbstractNode>;

	/** Human-readable display name */
	public abstract readonly label: string;

	/** Description for component picker */
	public abstract readonly description: string;

	/** Category for grouping modules */
	public abstract readonly category: ComponentCategory;

	/** Searchable tags for filtering */
	public abstract readonly tags: readonly string[];

	/**
	 * SVG icon content (inner content of the SVG tag, without the svg wrapper)
	 * The full SVG will be generated by getSvgIcon() with consistent attributes
	 * Example: '<rect width="18" height="18" x="3" y="3" rx="2"/>'
	 */
	public abstract readonly icon: string;

	/**
	 * Get the complete SVG icon string with standardized attributes
	 * @returns Complete SVG string ready for rendering
	 */
	public getSvgIcon(): string {
		return `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${this.icon}</svg>`;
	}

	/**
	 * Escapes HTML special characters in a string to prevent XSS.
	 *
	 * Use this explicitly in `compose()` when a field value will be
	 * interpolated into raw HTML (e.g. in a custom adapter or SSR context).
	 * Adapters like Svelte handle escaping automatically for text nodes and
	 * attributes, so escaping is only needed when using `{@html ...}` or
	 * an equivalent pattern.
	 *
	 * Handles: & < > " '
	 *
	 * @param value - The string to escape
	 * @returns The HTML-escaped string
	 */
	protected escapeHtml(value: string): string {
		return value
			.replace(/&/g, "&amp;")
			.replace(/</g, "&lt;")
			.replace(/>/g, "&gt;")
			.replace(/"/g, "&quot;")
			.replace(/'/g, "&#39;");
	}

	/**
	 * Helper method to parse a field value from module data.
	 *
	 * Returns the parsed value as-is. If the value will be interpolated into
	 * raw HTML, wrap the result with {@link escapeHtml} explicitly — the
	 * decision belongs to the module author who knows the rendering context.
	 *
	 * @param moduleData - The module data from UJL document
	 * @param key - The field key to parse
	 * @param fallback - Value returned when the field key is unknown to this module,
	 *   or when `field.parse()` returns nullish. Note: most built-in fields return
	 *   their own configured default on invalid input, so `fallback` is typically
	 *   only reached for missing or unregistered keys.
	 * @returns Parsed field value, or fallback if the key is unknown or parse returns nullish
	 */
	protected parseField<T>(moduleData: UJLCModuleObject, key: string, fallback: T): T {
		const entry = this.fields.find((f) => f.key === key);
		if (!entry) return fallback;
		const parsed = entry.field.parse(moduleData.fields[key]);
		return (parsed ?? fallback) as T;
	}

	/**
	 * Helper to create an AST node with the required id and meta fields.
	 *
	 * The generic parameter `T` is inferred from `type` and constrains `props` to the
	 * exact shape defined in the discriminated union — callers get a compile-time error
	 * if the wrong props are passed for a given node type.
	 *
	 * @param type - Node type string (must be a member of `UJLAbstractNode["type"]`)
	 * @param props - Props for the given node type (enforced by the discriminated union)
	 * @param moduleData - The module data from the UJL document (provides moduleId)
	 * @param isModuleRoot - true for the root node of a module, false for internal child nodes
	 */
	protected createNode<T extends UJLAbstractNode["type"]>(
		type: T,
		props: Extract<UJLAbstractNode, { type: T }>["props"],
		moduleData: UJLCModuleObject,
		isModuleRoot = true,
	): Extract<UJLAbstractNode, { type: T }> {
		return {
			type,
			props,
			id: generateUid(),
			meta: {
				moduleId: moduleData.meta.id,
				isModuleRoot,
			},
		} as Extract<UJLAbstractNode, { type: T }>;
	}
}
